#include <algorithm>
#include <string>
#include <bitcoin/bitcoin.hpp>

bc::ec_secret random_secret();
std::string bitcoin_address(const bc::ec_secret &secret);

int main(int argc, char *argv[])
{
    bc::ec_secret secret = random_secret();
    std::cout << "Secret: " << bc::encode_base16(secret) << std::endl;

    bc::ec_compressed public_key;
    bc::secret_to_public(public_key, secret);
    std::cout << "Pulbic Key: " << bc::encode_base16(public_key) << std::endl;

    const bc::short_hash hash = bc::bitcoin_short_hash(public_key);

    bc::data_chunk unencoded_address;
    // version: 1, hash: 20, checksum: 4
    unencoded_address.reserve(25);
    // 0 -> normal BTC address (P2PKH)
    unencoded_address.push_back(0);
    // Hash Data
    bc::extend_data(unencoded_address, hash);
    // Checksum
    bc::append_checksum(unencoded_address);

    assert(unencoded_address.size() == 25);

    const std::string actual = bc::encode_base58(unencoded_address);
    const std::string expected = bitcoin_address(secret);

    assert(actual == expected);

    std::cout << "Address: " << actual << std::endl;

    return EXIT_SUCCESS;
}

// CAUTION: Depending on implementation this RNG may not be secure enough!
// CAUTION: Do not use vanity keys generated by this example in production.
bc::ec_secret random_secret()
{
    // Create a new secret.
    bc::ec_secret secret;

    // Fill a secret-sized buffer with random data.
    bc::data_chunk buffer(secret.size());
    bc::pseudo_random_fill(buffer);

    // Copy the data to the secret and return it.
    bc::build_array(secret, {buffer});
    return secret;
}

std::string bitcoin_address(const bc::ec_secret &secret)
{
    bc::ec_compressed public_key;
    bc::secret_to_public(public_key, secret);
    bc::wallet::payment_address address(public_key);
    return address.encoded();
}
